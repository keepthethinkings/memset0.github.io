<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta content="IE=edge" http-equiv="X-UA-Compatible">
	<meta content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width" name="viewport">
	<title>近似算法 - blue's blog</title>

	<!-- css -->
	<link href="/css/base.min.css" rel="stylesheet">
	<link href="/css/project.min.css" rel="stylesheet">
	<link href="/css/styles.css" rel="stylesheet">


	<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	<script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>
<body class="page-brand">
	
	<nav class="menu menu-left nav-drawer nav-drawer-md" id="ui_menu">
		<div class="menu-scroll">
			<div class="menu-content">
				<a class="menu-logo" href="/">blue的博客</a>
				<ul class="nav">
					<li>

						<a class="collapsed waves-attach waves-effect" data-toggle="collapse" href="#posts">OI笔记</a>	
						<ul class="menu-collapse collapse in" id="posts">
							
							<li>
								<a class="waves-attach" href="/post/特征方程.html">特征方程教程</a>
							</li><li class="active">
								<a class="waves-attach" href="/post/近似算法.html">近似算法</a>
							</li><li>
								<a class="waves-attach" href="/post/SG函数.html">SG函数</a>
							</li><li>
								<a class="waves-attach" href="/post/Matrix-Tree.html">Matrix-Tree定理</a>
							</li><li>
								<a class="waves-attach" href="/post/polya.html">polya定理</a>
							</li><li>
								<a class="waves-attach" href="/post/NOIP2016.html">NOIP2016游记</a>
							</li><li>
								<a class="waves-attach" href="/post/有限微积分.html">差分与有限微积分</a>
							</li><li>
								<a class="waves-attach" href="/post/概率论.html">概率论</a>
							</li><li>
								<a class="waves-attach" href="/post/博弈论.html">博弈论入门</a>
							</li><li>
								<a class="waves-attach" href="/post/级数相关.html">级数相关</a>
							</li><li>
								<a class="waves-attach" href="/post/母函数.html">浅谈母函数</a>
							</li><li>
								<a class="waves-attach" href="/post/FFT.html">FFT入门</a>
							</li><li>
								<a class="waves-attach" href="/post/三分查找.html">三分查找</a>
							</li><li>
								<a class="waves-attach" href="/post/Miller_Rabin.html">Miller_Rabin判素</a>
							</li><li>
								<a class="waves-attach" href="/post/HNSDFZ-Round4酱油记.html">HNSDFZ#4 酱油记</a>
							</li><li>
								<a class="waves-attach" href="/post/牛顿迭代.html">牛顿迭代法</a>
							</li><li>
								<a class="waves-attach" href="/post/泰勒展开.html">泰勒展开</a>
							</li><li>
								<a class="waves-attach" href="/post/狄利克雷卷积.html">狄利克雷卷积</a>
							</li><li>
								<a class="waves-attach" href="/post/单调队列.html">单调队列</a>
							</li><li>
								<a class="waves-attach" href="/post/数值积分算法.html">数值积分算法</a>
							</li><li>
								<a class="waves-attach" href="/post/字符串hash.html">字符串hash</a>
							</li><li>
								<a class="waves-attach" href="/post/MEET-IN-THE-MIDDLE.html">Meet in the Middle</a>
							</li><li>
								<a class="waves-attach" href="/post/定积分.html">定积分与牛顿-莱布尼兹公式</a>
							</li><li>
								<a class="waves-attach" href="/post/HNSDFZ-Round3胡策记.html">HNSDFZ#3 胡策记</a>
							</li><li>
								<a class="waves-attach" href="/post/数学归纳法.html">数学归纳法</a>
							</li><li>
								<a class="waves-attach" href="/post/导数.html">导数</a>
							</li><li>
								<a class="waves-attach" href="/post/普通线段树.html">普通线段树</a>
							</li><li>
								<a class="waves-attach" href="/post/矩阵与递推.html">矩阵与递推</a>
							</li>						</ul>

						<a class="collapsed waves-attach waves-effect" data-toggle="collapse" href="#hack">渗透日志</a>	
						<ul class="menu-collapse collapse in" id="hack">
							
							<li>
								<a class="waves-attach" href="/hack/XSS.html">初探XSS</a>
							</li>						</ul>

					</li>
					
				</ul>
			</div>
		</div>
	</nav>
	<header class="header header-transparent header-waterfall ui-header">
		<ul class="nav nav-list pull-left hidden-md hidden-lg">
			<li>
				<a data-toggle="menu" href="#ui_menu">
					<span class="icon icon-lg">menu</span>
				</a>
			</li>
		</ul>
		<span class="header-logo header-affix visible-md-block visible-lg-block margin-right-no" data-offset-top="0" data-spy="affix">
			<p class="pagetitle">近似算法</p>
		</span>
		
		<ul class="nav nav-list pull-right">
			<li>
				<a data-toggle="menu" href="/">
					<span class="avatar avatar-sm"><img alt="blue" src="https://i.loli.net/2017/10/21/59eb6654682d2.png"></span>
				</a>
			</li>
		</ul>
	</header>
	<main class="content">
		<div class="container">
			<div class="row">
				<div class="col-lg-6 col-lg-offset-3 col-md-10 col-md-offset-1">
					<section class="content-inner margin-top-no">
						<br>
						
<h1>近似算法</h1>
<div class="card"><div class="card-main"><div class="card-inner">
<p>一万年没更新博客了……毕竟我这么弱。<br />
来玩一玩模拟退火算法和遗传算法。</p>
</div></div></div>
<p>我们的问题是，给定一个乱七八糟的函数，求它在某个区域内的最大值。</p>
<h2>模拟退火算法</h2>
<h3>爬山</h3>
<p>爬山算法是纯粹的贪心算法。给定一个起始点，我们能爬到一个极大值。</p>
<div class="codehilite"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.001</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>  <span class="n">x</span><span class="o">+=</span><span class="mf">0.001</span><span class="p">;</span>         
    <span class="c1">//如果向右走有利，则向右走</span>
    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.001</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">)</span> <span class="n">x</span><span class="o">+=</span><span class="mf">0.001</span><span class="p">;</span>
    <span class="c1">//如果向左走有利，则向左走</span>

    <span class="k">else</span> <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>       <span class="c1">//已经爬到极大值</span>
<span class="p">}</span>
</pre></div>


<p>爬山的缺陷在于，它会陷入局部最优解，而难以爬到全局最优解。例如下图。
<img style="max-width:100%" alt="爬山" src="http://i1.piimg.com/567571/42e0f0a7fea0b290.png" /></p>
<p>我们把上面的<code>x+0.001</code>之类的操作称作“移动”。</p>
<h3>经典模拟退火</h3>
<p>模拟退火的思想在于，如果一个移动会<strong>使答案变得更优</strong>，我们就接受这个移动；否则我们以<strong>一定的概率</strong>接受这个移动。</p>
<p>听起来很玄学。根据物理的那套理论，我们定义两个东西：<br />
- 温度<mathjax>$(T)$</mathjax>。它随着时间推移而逐渐降低。<br />
- 增量<mathjax>$(E)$</mathjax>。它描述一次移动获得的好处。从<mathjax>$x$</mathjax>移动到<mathjax>$x'$</mathjax>的增量定义为<mathjax>$f(x')-f(x)$</mathjax>，增量越大，往<mathjax>$x'$</mathjax>移动的优势越大。  </p>
<p>在模拟退火中，如果增量大于<mathjax>$0$</mathjax>，则直接接受这次移动；否则按下面的概率接受移动：</p>
<p><mathjax>$$P = \exp(\frac{E}{T})$$</mathjax></p>
<p>听起来十分的玄学。然而它竟然可以得出精度比较好的解。伪代码如下：</p>
<div class="codehilite"><pre><span></span><span class="n">T</span><span class="o">=</span><span class="mf">100.0</span><span class="p">;</span>               <span class="c1">//初始温度</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>      <span class="c1">//控制迭代次数</span>
<span class="p">{</span>
    <span class="n">tar</span><span class="o">=</span><span class="n">getPos</span><span class="p">();</span>           <span class="c1">//在x的周围选一个点</span>
    <span class="n">E</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">tar</span><span class="p">)</span><span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">E</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span> <span class="n">x</span><span class="o">=</span><span class="n">tar</span><span class="p">;</span>      <span class="c1">//直接移动</span>
    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">E</span><span class="o">/</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="n">x</span><span class="o">=</span><span class="n">tar</span><span class="p">;</span>     <span class="c1">//接受移动</span>

    <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="o">*</span><span class="mf">0.99</span><span class="p">;</span>               <span class="c1">//降温</span>
<span class="p">}</span>
</pre></div>


<h2>遗传算法</h2>
<p>不妨假设有一大群兔子，它们均匀地分布在各种地方。<br />
由于一些黑恶势力的影响，每年只有位置最高的那100只兔子能活下来。  </p>
<p>位置最高的那些兔子们繁衍生息，它们的后代有些比它们站得高，于是这些后代活了下来；其他后代被黑恶势力搞死了。每年都只有站得最高的100只兔子能活下来。</p>
<p>在无尽的岁月后，这100只兔子想必都站在了世界上最高的山峰。</p>
<p>这个算法听起来比模拟退火靠谱。现在它的实现过程如下：</p>
<ol>
<li>先随机产生100个点，均匀地分布在所求区间上。</li>
<li>取每两个点的中位数，这样我们共获得了10000个点。</li>
<li>取出最高的100个点，然后开始新一轮迭代。</li>
</ol>
<p>但是这会引发一个问题。例如下图：</p>
<p><img style="max-width:100%" alt="问题" src="http://i1.piimg.com/567571/0d87fe3e1bcc6437.png" /></p>
<p>这样的话，无论我们迭代多少次，总是找不到最高点（因为是取中位数）。这搞屁。</p>
<p>所以我们引入<strong>变异</strong>。每个数都有二进制表示，我们产生一个数之后，对它进行变异操作：二进制的每一位都以<mathjax>$p$</mathjax>的概率翻转。</p>
<p>这样的话，由于变异的存在，迭代若干次之后，最高点是找得到的。</p>
<p>那么问题来了。<strong><mathjax>$p$</mathjax>到底取多少？</strong></p>
<p>恭喜您打开了黑暗世界的大门——玄学调参数。由于我们很难给出一个很妙的<mathjax>$p$</mathjax>，遗传算法变得比模拟退火还不靠谱。</p>
<p>如何玄学调参数呢？我们造一些区间比较小的数据，暴力求出答案，然后根据这些数据来调整<mathjax>$p$</mathjax>。猜很多个<mathjax>$p$</mathjax>的值，看哪个最好。我们只需要考虑<mathjax>$p&lt;0.5$</mathjax>的情况，因为<code>以p的概率翻转</code>，和<code>以p的概率不翻转</code>是本质相同的。</p>
						
					</section>
				</div>
			</div>

			<div class="row">
				<div class="col-lg-6 col-lg-offset-3 col-md-10 col-md-offset-1">
					<section class="content-inner margin-top-no">
						<hr>
						
							CC0协议 @ ruanxingzhi 2017.
						<a style="float:right" href="/CC0.html">CC0是啥玩意?</a>
					</section>
				</div>
			</div>

			<!-- UY BEGIN -->
			<div id="uyan_frame"></div>
			<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2128300"></script>
			<!-- UY END -->


		</div>


	</main>
	
	<div class="fbtn-container">
		<div class="fbtn-inner">
			<a class="fbtn fbtn-lg fbtn-brand-accent waves-attach waves-circle waves-light" data-toggle="dropdown">
				<span class="fbtn-text fbtn-text-left">Home</span>
				<span class="fbtn-ori icon">apps</span>
				<span class="fbtn-sub icon">close</span>
			</a>
			<div class="fbtn-dropup">
				<a class="fbtn waves-attach waves-circle" href="/about.html" target="_blank">
					<span class="fbtn-text fbtn-text-left">关于作者</span><span class="icon">perm_identity</span>
				</a>
				<a class="fbtn waves-attach waves-circle" href="https://coding.net/u/ruanxingzhi/p/blog/topic" target="_blank">
					<span class="fbtn-text fbtn-text-left">反馈</span><span class="icon">feedback</span>
				</a>
				<a class="fbtn fbtn-green waves-attach waves-circle" href="/" target="_self">
					<span class="fbtn-text fbtn-text-left">返回主页</span><span class="icon">home</span>
				</a>
			</div>
		</div>
	</div>

	

	<!-- js -->
	<script src="/js/jquery.min.js"></script>
	<script src="/js/base.min.js"></script>
</body>
</html>